#!/usr/bin/env python3
"""
Send Nightly Unit Test Status Notifications to Microsoft Teams

This script sends alerts about unit test results to Microsoft Teams channels via webhooks.
It's designed to work with the test_nightly.sh script to provide automated alerts
when unit tests pass or fail by parsing the generated log files.

USAGE:
    python send_test_nightly_alert.py --webhook-url "https://teams.webhook.url" --log-file "/path/to/test.log"
    python send_test_nightly_alert.py --webhook-url "https://teams.webhook.url" --test-mode

ENVIRONMENT VARIABLES:
    TEAMS_WEBHOOK_URL: Teams webhook URL (required if not provided via --webhook-url)

REQUIREMENTS:
    - requests library
    - pytz library (optional, for timezone handling)
"""

import argparse
import json
import os
import re
import sys
from datetime import datetime
from typing import Dict, Optional

import requests

try:
    import pytz

    PYTZ_AVAILABLE = True
except ImportError:
    PYTZ_AVAILABLE = False
    print("‚ö†Ô∏è  Warning: pytz not available, using UTC time instead of Pacific time")


def parse_test_log(log_file_path: str) -> Dict:
    """
    Parse the test log file generated by test_nightly.sh

    Args:
        log_file_path: Path to the log file

    Returns:
        Dictionary containing parsed test information
    """
    parsed_data = {
        "status": "unknown",
        "runtime": None,
        "exit_code": None,
        "docker_image": None,
        "hardware": None,
        "test_name": None,
        "gpus_used": None,
        "start_time": None,
        "end_time": None,
        "error_details": None,
        "hostname": None,
    }

    try:
        with open(log_file_path, "r", encoding="utf-8", errors="ignore") as f:
            content = f.read()

        # Extract result status
        result_match = re.search(r"Result:\s*(\w+)", content)
        if result_match:
            result = result_match.group(1).upper()
            parsed_data["status"] = "pass" if result == "PASSED" else "fail"

        # Extract exit code
        exit_code_match = re.search(r"Exit code:\s*(\d+)", content)
        if exit_code_match:
            parsed_data["exit_code"] = int(exit_code_match.group(1))
            # If we didn't get status from Result line, infer from exit code
            if parsed_data["status"] == "unknown":
                parsed_data["status"] = (
                    "pass" if parsed_data["exit_code"] == 0 else "fail"
                )

        # Extract Docker image
        image_match = re.search(r"Image:\s*(.+)", content)
        if image_match:
            parsed_data["docker_image"] = image_match.group(1).strip()

        # Extract hardware
        hardware_match = re.search(r"Hardware:\s*(.+)", content)
        if hardware_match:
            parsed_data["hardware"] = hardware_match.group(1).strip()

        # Extract test name
        test_match = re.search(r"Test:\s*(.+)", content)
        if test_match:
            parsed_data["test_name"] = test_match.group(1).strip()

        # Extract GPUs used from command line
        gpu_match = re.search(r"CUDA_VISIBLE_DEVICES=([0-9,]+)", content)
        if gpu_match:
            parsed_data["gpus_used"] = gpu_match.group(1)

        # Extract hostname/machine name
        hostname_match = re.search(r"Machine:\s*(.+)", content)
        if hostname_match:
            parsed_data["hostname"] = hostname_match.group(1).strip()

        # Extract start and end times for runtime calculation
        start_match = re.search(r"Start time:\s*(.+)", content)
        end_match = re.search(r"End time:\s*(.+)", content)

        if start_match and end_match:
            start_str = start_match.group(1).strip()
            end_str = end_match.group(1).strip()
            parsed_data["start_time"] = start_str
            parsed_data["end_time"] = end_str

            # Calculate runtime
            try:
                # Try to parse the datetime strings
                # Handle different possible formats
                time_formats = [
                    "%Y-%m-%d %H:%M:%S %Z",  # 2025-09-03 22:42:28 CDT
                    "%Y-%m-%d %H:%M:%S %z",  # With timezone offset
                    "%Y-%m-%d %H:%M:%S",  # Without timezone
                ]

                start_dt = None
                end_dt = None

                for fmt in time_formats:
                    try:
                        # Remove timezone abbreviations like CDT, CST, etc. for parsing
                        start_clean = re.sub(r"\s+[A-Z]{3,4}$", "", start_str)
                        end_clean = re.sub(r"\s+[A-Z]{3,4}$", "", end_str)

                        if fmt == "%Y-%m-%d %H:%M:%S":
                            start_dt = datetime.strptime(start_clean, fmt)
                            end_dt = datetime.strptime(end_clean, fmt)
                            break
                    except ValueError:
                        continue

                if start_dt and end_dt:
                    duration = end_dt - start_dt
                    total_seconds = int(duration.total_seconds())

                    # Format duration as "5m 23s" or "1h 5m 23s"
                    hours = total_seconds // 3600
                    minutes = (total_seconds % 3600) // 60
                    seconds = total_seconds % 60

                    if hours > 0:
                        parsed_data["runtime"] = f"{hours}h {minutes}m {seconds}s"
                    else:
                        parsed_data["runtime"] = f"{minutes}m {seconds}s"

            except Exception as e:
                print(f"Warning: Could not calculate runtime: {e}")

        # For failed tests, try to extract error details
        if parsed_data["status"] == "fail":
            # Look for common error patterns
            error_patterns = [
                r"FAILED \((.+?)\)",
                r"AssertionError: (.+)",
                r"Error: (.+)",
                r"Exception: (.+)",
            ]

            for pattern in error_patterns:
                error_match = re.search(pattern, content, re.DOTALL)
                if error_match:
                    error_text = error_match.group(1).strip()
                    # Limit error details to reasonable length
                    if len(error_text) > 200:
                        error_text = error_text[:200] + "..."
                    parsed_data["error_details"] = error_text
                    break

    except FileNotFoundError:
        print(f"‚ùå Error: Log file not found: {log_file_path}")
        return None
    except Exception as e:
        print(f"‚ùå Error parsing log file: {e}")
        return None

    return parsed_data


class TestNightlyTeamsNotifier:
    """Handle sending unit test status notifications to Microsoft Teams"""

    def __init__(self, webhook_url: str):
        """
        Initialize Teams notifier for unit tests

        Args:
            webhook_url: Microsoft Teams webhook URL
        """
        self.webhook_url = webhook_url

    def create_test_status_card(
        self,
        status: str,
        runtime: Optional[str] = None,
        hostname: Optional[str] = None,
        docker_image: Optional[str] = None,
        hardware: Optional[str] = None,
        test_name: Optional[str] = None,
        log_file: Optional[str] = None,
        error_details: Optional[str] = None,
    ) -> dict:
        """
        Create adaptive card for unit test status

        Args:
            status: Test status (pass, fail)
            runtime: Test execution runtime
            hostname: Hostname where test ran
            docker_image: Docker image used for testing
            hardware: Hardware type (mi30x, mi35x)
            test_name: Name of the test that ran
            log_file: Path to the log file
            error_details: Additional error information for failed tests

        Returns:
            Adaptive card JSON structure
        """
        # Use San Francisco time (Pacific Time) if pytz is available
        if PYTZ_AVAILABLE:
            pacific_tz = pytz.timezone("America/Los_Angeles")
            pacific_time = datetime.now(pacific_tz)
            current_date = pacific_time.strftime("%Y-%m-%d")
            # Determine if it's PST or PDT
            tz_name = "PDT" if pacific_time.dst() else "PST"
            current_time = pacific_time.strftime(f"%H:%M:%S {tz_name}")
        else:
            current_date = datetime.now().strftime("%Y-%m-%d")
            current_time = datetime.now().strftime("%H:%M:%S UTC")

        # Determine status icon and color
        status_config = {
            "pass": {
                "icon": "‚úÖ",
                "color": "Good",
                "title": "Unit Test Passed",
            },
            "fail": {
                "icon": "‚ùå",
                "color": "Attention",
                "title": "Unit Test Failed",
            },
        }

        config = status_config.get(status, status_config["fail"])

        # Create card body elements
        body_elements = [
            {
                "type": "TextBlock",
                "size": "Large",
                "weight": "Bolder",
                "text": f"{current_date} SGL Nightly Unit Test Results",
            },
            {
                "type": "TextBlock",
                "size": "Small",
                "text": f"Completed on {current_date} at {current_time}",
                "isSubtle": True,
                "spacing": "None",
            },
            {
                "type": "TextBlock",
                "text": "**Test Status:**",
                "weight": "Bolder",
                "size": "Medium",
                "spacing": "Medium",
            },
            {
                "type": "TextBlock",
                "size": "Medium",
                "weight": "Bolder",
                "text": f"{config['icon']} {config['title']}",
                "color": config["color"],
                "wrap": True,
                "spacing": "Small",
            },
        ]

        # Add test details section
        body_elements.append(
            {
                "type": "TextBlock",
                "text": "**unit-test-backend-8-gpu-CAR-amd:**",
                "weight": "Bolder",
                "size": "Medium",
                "spacing": "Medium",
            }
        )

        # Add test detail (actual test name) if provided
        if test_name:
            body_elements.append(
                {
                    "type": "TextBlock",
                    "text": f"‚Ä¢ Test detail: **{test_name}**",
                    "wrap": True,
                    "size": "Small",
                    "spacing": "None",
                }
            )

        # Add Docker image if provided
        if docker_image:
            body_elements.append(
                {
                    "type": "TextBlock",
                    "text": f"‚Ä¢ Docker Image: **{docker_image}**",
                    "wrap": True,
                    "size": "Small",
                    "spacing": "None",
                }
            )

        # Add hostname if provided
        if hostname:
            body_elements.append(
                {
                    "type": "TextBlock",
                    "text": f"‚Ä¢ Hostname: **{hostname}**",
                    "wrap": True,
                    "size": "Small",
                    "spacing": "None",
                }
            )

        # Add hardware type if provided
        if hardware:
            body_elements.append(
                {
                    "type": "TextBlock",
                    "text": f"‚Ä¢ Hardware: **{hardware}**",
                    "wrap": True,
                    "size": "Small",
                    "spacing": "None",
                }
            )

        # Add runtime if provided
        if runtime:
            body_elements.append(
                {
                    "type": "TextBlock",
                    "text": f"‚Ä¢ Runtime: **{runtime}**",
                    "wrap": True,
                    "size": "Small",
                    "spacing": "None",
                }
            )

        # Add log file path if provided
        if log_file:
            # Extract relative path from the base directory
            # Look for pattern like: .../sglang-ci/test/unit-test-backend-8-gpu-CAR-amd/filename.log
            import re

            relative_path_match = re.search(
                r".*sglang-ci/(test/unit-test-backend-8-gpu-CAR-amd/.+)",
                log_file,
            )
            display_path = (
                relative_path_match.group(1) if relative_path_match else log_file
            )

            body_elements.append(
                {
                    "type": "TextBlock",
                    "text": f"‚Ä¢ Log file: **{display_path}**",
                    "wrap": True,
                    "size": "Small",
                    "spacing": "None",
                }
            )

        # Add error details for failed tests
        if status == "fail" and error_details:
            body_elements.extend(
                [
                    {
                        "type": "TextBlock",
                        "text": "**Error Details:**",
                        "weight": "Bolder",
                        "size": "Medium",
                        "spacing": "Medium",
                    },
                    {
                        "type": "TextBlock",
                        "text": error_details,
                        "wrap": True,
                        "size": "Small",
                        "spacing": "Small",
                        "color": "Attention",
                    },
                ]
            )

        # Add troubleshooting section for failures
        if status == "fail":
            body_elements.extend(
                [
                    {
                        "type": "TextBlock",
                        "text": "**Troubleshooting:**",
                        "weight": "Bolder",
                        "size": "Medium",
                        "spacing": "Medium",
                    },
                    {
                        "type": "TextBlock",
                        "text": "‚Ä¢ Check the log file for detailed error information",
                        "wrap": True,
                        "size": "Small",
                        "spacing": "Small",
                    },
                    {
                        "type": "TextBlock",
                        "text": "‚Ä¢ Verify Docker image availability and GPU resources",
                        "wrap": True,
                        "size": "Small",
                        "spacing": "None",
                    },
                    {
                        "type": "TextBlock",
                        "text": "‚Ä¢ Check for recent code changes that may affect unit tests",
                        "wrap": True,
                        "size": "Small",
                        "spacing": "None",
                    },
                ]
            )

        # Create actions
        actions = []

        # Add cron log link
        # Priority 1: Extract hardware type from hardware parameter
        hw_type = None
        if hardware:
            import re

            hw_match = re.search(r"mi[0-9]+x", hardware)
            if hw_match:
                hw_type = hw_match.group(0)

        # If not found, try docker image
        if not hw_type and docker_image:
            import re

            hw_match = re.search(r"mi[0-9]+x", docker_image)
            if hw_match:
                hw_type = hw_match.group(0)

        # Priority 2: Extract from hostname
        if not hw_type:
            try:
                import re
                import socket

                hostname_str = hostname if hostname else socket.gethostname()
                # Try full pattern first (mi30x, mi35x)
                hw_match = re.search(r"mi[0-9]+x", hostname_str)
                if hw_match:
                    hw_type = hw_match.group(0)
                else:
                    # Try abbreviated patterns and convert to mi30x, mi35x
                    # Pattern 1: 300x, 350x, 355x (with 'x')
                    abbrev_match = re.search(r"([0-9]+)x", hostname_str)
                    if abbrev_match:
                        abbrev = abbrev_match.group(1)
                        # Map 300x -> mi30x, 350x/355x -> mi35x
                        if abbrev in ["300", "30"]:
                            hw_type = "mi30x"
                        elif abbrev in ["350", "355", "35"]:
                            hw_type = "mi35x"
                    # Pattern 2: 300, 355 (without 'x')
                    elif not hw_type:
                        abbrev_match = re.search(
                            r"\b(300|355|350|30|35)\b", hostname_str
                        )
                        if abbrev_match:
                            abbrev = abbrev_match.group(1)
                            # Map 300 -> mi30x, 355/350 -> mi35x
                            if abbrev in ["300", "30"]:
                                hw_type = "mi30x"
                            elif abbrev in ["350", "355", "35"]:
                                hw_type = "mi35x"
            except Exception:
                pass

        # Add cron log link if we have hardware type
        if hw_type:
            log_date = datetime.now().strftime("%Y%m%d")
            cron_log_url = f"https://github.com/michael-amd/sglang-ci-data/tree/main/cron_log/{hw_type}/{log_date}"
            actions.append(
                {
                    "type": "Action.OpenUrl",
                    "title": "üìã Cron Logs",
                    "url": cron_log_url,
                }
            )

        # Add GitHub repository link
        actions.append(
            {
                "type": "Action.OpenUrl",
                "title": "üêô View Repository",
                "url": "https://github.com/sgl-project/sglang",
            }
        )

        # Create the adaptive card
        card = {
            "type": "message",
            "attachments": [
                {
                    "contentType": "application/vnd.microsoft.card.adaptive",
                    "content": {
                        "type": "AdaptiveCard",
                        "$schema": "http://adaptivecards.io/schemas/adaptive-card.json",
                        "version": "1.4",
                        "body": body_elements,
                        "actions": actions,
                    },
                }
            ],
        }

        return card

    def create_test_card(self) -> dict:
        """
        Create a simple test card for unit test alerts

        Returns:
            Simple test adaptive card JSON structure
        """
        if PYTZ_AVAILABLE:
            pacific_tz = pytz.timezone("America/Los_Angeles")
            pacific_time = datetime.now(pacific_tz)
            current_time = pacific_time.strftime("%H:%M:%S %Z")
        else:
            current_time = datetime.now().strftime("%H:%M:%S UTC")

        card = {
            "type": "message",
            "attachments": [
                {
                    "contentType": "application/vnd.microsoft.card.adaptive",
                    "content": {
                        "type": "AdaptiveCard",
                        "$schema": "http://adaptivecards.io/schemas/adaptive-card.json",
                        "version": "1.4",
                        "body": [
                            {
                                "type": "TextBlock",
                                "size": "Large",
                                "weight": "Bolder",
                                "text": "üß™ Unit Test Alert Test",
                            },
                            {
                                "type": "TextBlock",
                                "text": f"Sent at {current_time}",
                                "isSubtle": True,
                                "spacing": "None",
                            },
                            {
                                "type": "TextBlock",
                                "text": "‚úÖ If you see this message, your Teams webhook is working correctly for unit test alerts!",
                                "wrap": True,
                                "spacing": "Medium",
                            },
                        ],
                    },
                }
            ],
        }
        return card

    def send_notification(
        self,
        log_file_path: str,
    ) -> bool:
        """
        Send unit test status notification to Teams by parsing log file

        Args:
            log_file_path: Path to the log file generated by test_nightly.sh

        Returns:
            True if successful, False otherwise
        """
        try:
            # Parse the log file
            print(f"üìã Parsing log file: {log_file_path}")
            parsed_data = parse_test_log(log_file_path)
            if parsed_data is None:
                return False

            # Use parsed hostname, fallback if not found in log
            hostname = parsed_data["hostname"]
            if hostname is None:
                try:
                    import socket

                    hostname = socket.gethostname()
                except Exception:
                    hostname = "unknown"

            card = self.create_test_status_card(
                parsed_data["status"],
                parsed_data["runtime"],
                hostname,
                parsed_data["docker_image"],
                parsed_data["hardware"],
                parsed_data["test_name"],
                log_file_path,
                parsed_data["error_details"],
            )
            card_json = json.dumps(card)

            headers = {"Content-Type": "application/json"}

            response = requests.post(
                self.webhook_url, data=card_json, headers=headers, timeout=30
            )

            if response.status_code in [200, 202]:
                print(
                    f"‚úÖ Successfully sent unit test {parsed_data['status']} alert to Teams"
                )
                if response.status_code == 202:
                    print(
                        "   (Power Automate flow accepted - message processing asynchronously)"
                    )
                return True
            else:
                print(
                    f"‚ùå Failed to send Teams notification. Status: {response.status_code}"
                )
                print(f"Response: {response.text}")
                return False

        except requests.exceptions.RequestException as e:
            print(f"‚ùå Error sending Teams notification: {e}")
            return False
        except json.JSONDecodeError as e:
            print(f"‚ùå JSON encoding error: {e}")
            return False

    def send_test_notification(self) -> bool:
        """
        Send a test notification to Teams

        Returns:
            True if successful, False otherwise
        """
        try:
            card = self.create_test_card()
            card_json = json.dumps(card)

            headers = {"Content-Type": "application/json"}

            response = requests.post(
                self.webhook_url, data=card_json, headers=headers, timeout=30
            )

            if response.status_code in [200, 202]:
                print("‚úÖ Test message sent successfully!")
                if response.status_code == 202:
                    print(
                        "   (Power Automate flow accepted - message processing asynchronously)"
                    )
                return True
            else:
                print(f"‚ùå Test failed. Status: {response.status_code}")
                print(f"Response: {response.text}")
                return False

        except requests.exceptions.RequestException as e:
            print(f"‚ùå Error sending test notification: {e}")
            return False
        except json.JSONDecodeError as e:
            print(f"‚ùå JSON encoding error: {e}")
            return False


def main():
    """Main function"""
    parser = argparse.ArgumentParser(
        description="Send nightly unit test status notifications to Microsoft Teams",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "--webhook-url",
        type=str,
        help="Teams webhook URL (overrides TEAMS_WEBHOOK_URL env var)",
    )

    parser.add_argument(
        "--test-mode",
        action="store_true",
        help="Send a simple test message to verify Teams connectivity",
    )

    parser.add_argument(
        "--log-file",
        type=str,
        help="Path to the log file generated by test_nightly.sh (required unless using --test-mode)",
    )

    args = parser.parse_args()

    # Get webhook URL
    webhook_url = args.webhook_url or os.environ.get("TEAMS_WEBHOOK_URL")
    if not webhook_url:
        print("‚ùå Error: Teams webhook URL not provided")
        print("   Set TEAMS_WEBHOOK_URL environment variable or use --webhook-url")
        return 1

    # Create notifier
    notifier = TestNightlyTeamsNotifier(webhook_url)

    # Handle test mode
    if args.test_mode:
        print("üß™ Test mode: Sending simple unit test alert test")
        success = notifier.send_test_notification()
        return 0 if success else 1

    # Validate required arguments for normal operation
    if not args.log_file:
        print("‚ùå Error: --log-file is required (unless using --test-mode)")
        return 1

    # Send notification
    success = notifier.send_notification(
        log_file_path=args.log_file,
    )

    return 0 if success else 1


if __name__ == "__main__":
    sys.exit(main())
