#!/usr/bin/env python3
"""
Send Nightly Unit Test Status Notifications to Microsoft Teams

This script sends alerts about unit test results to Microsoft Teams channels via webhooks.
It's designed to work with the test_nightly.sh script to provide automated alerts
when unit tests pass or fail by parsing the generated log files.

USAGE:
    python send_test_nightly_alert.py --webhook-url "https://teams.webhook.url" --log-file "/path/to/test.log"
    python send_test_nightly_alert.py --webhook-url "https://teams.webhook.url" --test-mode

ENVIRONMENT VARIABLES:
    TEAMS_WEBHOOK_URL: Teams webhook URL (required if not provided via --webhook-url)

REQUIREMENTS:
    - requests library
    - pytz library (optional, for timezone handling)
"""

import argparse
import json
import os
import re
import sys
from datetime import datetime
from typing import Dict, Optional

import requests

try:
    import pytz

    PYTZ_AVAILABLE = True
except ImportError:
    PYTZ_AVAILABLE = False
    print("‚ö†Ô∏è  Warning: pytz not available, using UTC time instead of Pacific time")


def parse_test_log(log_file_path: str) -> Dict:
    """
    Parse the test log file generated by test_nightly.sh

    Args:
        log_file_path: Path to the log file

    Returns:
        Dictionary containing parsed test information
    """
    parsed_data = {
        "status": "unknown",
        "runtime": None,
        "exit_code": None,
        "docker_image": None,
        "hardware": None,
        "test_name": None,
        "gpus_used": None,
        "start_time": None,
        "end_time": None,
        "error_details": None,
        "hostname": None,
    }

    try:
        with open(log_file_path, "r", encoding="utf-8", errors="ignore") as f:
            content = f.read()

        # Extract result status
        result_match = re.search(r"Result:\s*(\w+)", content)
        if result_match:
            result = result_match.group(1).upper()
            parsed_data["status"] = "pass" if result == "PASSED" else "fail"

        # Extract exit code
        exit_code_match = re.search(r"Exit code:\s*(\d+)", content)
        if exit_code_match:
            parsed_data["exit_code"] = int(exit_code_match.group(1))
            # If we didn't get status from Result line, infer from exit code
            if parsed_data["status"] == "unknown":
                parsed_data["status"] = (
                    "pass" if parsed_data["exit_code"] == 0 else "fail"
                )

        # Extract Docker image
        image_match = re.search(r"Image:\s*(.+)", content)
        if image_match:
            parsed_data["docker_image"] = image_match.group(1).strip()

        # Extract hardware
        hardware_match = re.search(r"Hardware:\s*(.+)", content)
        if hardware_match:
            parsed_data["hardware"] = hardware_match.group(1).strip()

        # Extract test name
        test_match = re.search(r"Test:\s*(.+)", content)
        if test_match:
            parsed_data["test_name"] = test_match.group(1).strip()

        # Extract GPUs used from command line
        gpu_match = re.search(r"CUDA_VISIBLE_DEVICES=([0-9,]+)", content)
        if gpu_match:
            parsed_data["gpus_used"] = gpu_match.group(1)

        # Extract hostname/machine name
        hostname_match = re.search(r"Machine:\s*(.+)", content)
        if hostname_match:
            parsed_data["hostname"] = hostname_match.group(1).strip()

        # Extract start and end times for runtime calculation
        start_match = re.search(r"Start time:\s*(.+)", content)
        end_match = re.search(r"End time:\s*(.+)", content)

        if start_match and end_match:
            start_str = start_match.group(1).strip()
            end_str = end_match.group(1).strip()
            parsed_data["start_time"] = start_str
            parsed_data["end_time"] = end_str

            # Calculate runtime
            try:
                # Try to parse the datetime strings
                # Handle different possible formats
                time_formats = [
                    "%Y-%m-%d %H:%M:%S %Z",  # 2025-09-03 22:42:28 CDT
                    "%Y-%m-%d %H:%M:%S %z",  # With timezone offset
                    "%Y-%m-%d %H:%M:%S",  # Without timezone
                ]

                start_dt = None
                end_dt = None

                for fmt in time_formats:
                    try:
                        # Remove timezone abbreviations like CDT, CST, etc. for parsing
                        start_clean = re.sub(r"\s+[A-Z]{3,4}$", "", start_str)
                        end_clean = re.sub(r"\s+[A-Z]{3,4}$", "", end_str)

                        if fmt == "%Y-%m-%d %H:%M:%S":
                            start_dt = datetime.strptime(start_clean, fmt)
                            end_dt = datetime.strptime(end_clean, fmt)
                            break
                    except ValueError:
                        continue

                if start_dt and end_dt:
                    duration = end_dt - start_dt
                    total_seconds = int(duration.total_seconds())

                    # Format duration as "5m 23s" or "1h 5m 23s"
                    hours = total_seconds // 3600
                    minutes = (total_seconds % 3600) // 60
                    seconds = total_seconds % 60

                    if hours > 0:
                        parsed_data["runtime"] = f"{hours}h {minutes}m {seconds}s"
                    else:
                        parsed_data["runtime"] = f"{minutes}m {seconds}s"

            except Exception as e:
                print(f"Warning: Could not calculate runtime: {e}")

        # For failed tests, try to extract error details
        if parsed_data["status"] == "fail":
            # Look for common error patterns (in order of preference)
            # We search for the LAST occurrence as it's usually the final failure reason
            error_patterns = [
                # RuntimeError (prioritize - usually most meaningful)
                (r"RuntimeError:\s*(.+?)(?:\n\n|\nTraceback|\n[A-Z]|\Z)", 250),
                # AssertionError with message
                (r"AssertionError:\s*(.+?)(?:\n\n|\nTraceback|\n[A-Z]|\Z)", 200),
                # Other specific exceptions
                (r"(ValueError|TypeError|AttributeError|KeyError|ImportError|OSError|IOError):\s*(.+?)(?:\n\n|\nTraceback|\n[A-Z]|\Z)", 200),
                # Generic Error/Exception
                (r"Error:\s*(.+?)(?:\n\n|\n[A-Z]|\Z)", 150),
                (r"Exception:\s*(.+?)(?:\n\n|\n[A-Z]|\Z)", 150),
                # FAILED with error count
                (r"FAILED \((.+?)\)", 100),
            ]

            for pattern, max_length in error_patterns:
                # Find all matches and take the last one
                matches = list(re.finditer(pattern, content, re.DOTALL))
                if matches:
                    error_match = matches[-1]  # Take the last match
                    
                    # For patterns with two groups (exception type + message)
                    if error_match.lastindex == 2:
                        error_type = error_match.group(1).strip()
                        error_msg = error_match.group(2).strip()
                        error_text = f"{error_type}: {error_msg}"
                    else:
                        error_text = error_match.group(1).strip()
                    
                    # Clean up the error text
                    error_text = error_text.replace('\n', ' ').strip()
                    # Remove ANSI color codes
                    error_text = re.sub(r'\[\d+m', '', error_text)
                    
                    # Limit error details to reasonable length
                    if len(error_text) > max_length:
                        error_text = error_text[:max_length] + "..."
                    
                    parsed_data["error_details"] = error_text
                    break

    except FileNotFoundError:
        print(f"‚ùå Error: Log file not found: {log_file_path}")
        return None
    except Exception as e:
        print(f"‚ùå Error parsing log file: {e}")
        return None

    return parsed_data


def parse_pd_test_summary(summary_file_path: str) -> Dict:
    """
    Parse the PD test summary file generated by run_pd_docker.sh

    Args:
        summary_file_path: Path to the test_summary.txt file

    Returns:
        Dictionary containing parsed PD test information
    """
    parsed_data = {
        "status": "unknown",
        "docker_image": None,
        "hardware": None,
        "model": None,
        "model_path": None,
        "hostname": None,
        "ip_address": None,
        "prefill_port": None,
        "prefill_gpus": None,
        "decode_port": None,
        "decode_gpus": None,
        "router_port": None,
        "test_results": {},
        "gsm8k_accuracy": None,
        "total_runtime": None,
        "setup_time": None,
        "gsm8k_duration": None,
        "log_dir": None,
    }

    try:
        with open(summary_file_path, "r", encoding="utf-8", errors="ignore") as f:
            content = f.read()

        # Extract basic information
        docker_image_match = re.search(r"Docker Image:\s*(.+)", content)
        if docker_image_match:
            parsed_data["docker_image"] = docker_image_match.group(1).strip()

        hardware_match = re.search(r"^Hardware:\s*(.+)", content, re.MULTILINE)
        if hardware_match:
            parsed_data["hardware"] = hardware_match.group(1).strip()

        model_match = re.search(r"^Model:\s*(.+)", content, re.MULTILINE)
        if model_match:
            parsed_data["model"] = model_match.group(1).strip()

        model_path_match = re.search(r"Model Path:\s*(.+)", content)
        if model_path_match:
            parsed_data["model_path"] = model_path_match.group(1).strip()

        # Extract hostname
        hostname_match = re.search(r"^Hostname:\s*(.+)", content, re.MULTILINE)
        if hostname_match:
            parsed_data["hostname"] = hostname_match.group(1).strip()

        # Extract configuration details
        ip_match = re.search(r"IP Address:\s*(.+)", content)
        if ip_match:
            parsed_data["ip_address"] = ip_match.group(1).strip()
            # Use IP as hostname fallback if hostname not found
            if not parsed_data["hostname"]:
                parsed_data["hostname"] = parsed_data["ip_address"]

        prefill_match = re.search(
            r"Prefill Server:\s*Port\s*(\d+),\s*GPUs\s*([\d\-]+)", content
        )
        if prefill_match:
            parsed_data["prefill_port"] = prefill_match.group(1)
            parsed_data["prefill_gpus"] = prefill_match.group(2)

        decode_match = re.search(
            r"Decode Server:\s*Port\s*(\d+),\s*GPUs\s*([\d\-]+)", content
        )
        if decode_match:
            parsed_data["decode_port"] = decode_match.group(1)
            parsed_data["decode_gpus"] = decode_match.group(2)

        router_match = re.search(r"Load Balancer:\s*Port\s*(\d+)", content)
        if router_match:
            parsed_data["router_port"] = router_match.group(1)

        # Extract test results
        test_patterns = {
            "health_check": r"Test 1 - Health Check:\s*(PASS|FAIL)\s*\((\d+)s\)",
            "simple_completion": r"Test 3 - Simple Completion:\s*(PASS|FAIL)\s*\((\d+)s\)",
            "code_generation": r"Test 4 - Code Generation:\s*(PASS|FAIL)\s*\((\d+)s\)",
            "gsm8k": r"Test 6 - GSM8K Accuracy:\s*([\d\.]+|FAILED|N/A)\s*\[(PASS|FAIL)\]\s*\((\d+)s\)",
        }

        for test_name, pattern in test_patterns.items():
            match = re.search(pattern, content)
            if match:
                if test_name == "gsm8k":
                    accuracy = match.group(1)
                    result = match.group(2)
                    duration = match.group(3)
                    parsed_data["test_results"][test_name] = {
                        "status": result,
                        "duration": duration,
                        "accuracy": accuracy,
                    }
                    parsed_data["gsm8k_accuracy"] = accuracy
                else:
                    parsed_data["test_results"][test_name] = {
                        "status": match.group(1),
                        "duration": match.group(2),
                    }

        # Extract timing information
        total_runtime_match = re.search(
            r"Total Time \(Setup \+ Tests\):\s*(\d+)s", content
        )
        if total_runtime_match:
            total_seconds = int(total_runtime_match.group(1))
            hours = total_seconds // 3600
            minutes = (total_seconds % 3600) // 60
            seconds = total_seconds % 60
            if hours > 0:
                parsed_data["total_runtime"] = f"{hours}h {minutes}m {seconds}s"
            else:
                parsed_data["total_runtime"] = f"{minutes}m {seconds}s"

        setup_time_match = re.search(r"Setup Time \(Steps 1-4\):\s*(\d+)s", content)
        if setup_time_match:
            setup_seconds = int(setup_time_match.group(1))
            minutes = setup_seconds // 60
            seconds = setup_seconds % 60
            parsed_data["setup_time"] = f"{minutes}m {seconds}s"

        gsm8k_duration_match = re.search(r"GSM8K Test Duration:\s*(\d+)s", content)
        if gsm8k_duration_match:
            gsm8k_seconds = int(gsm8k_duration_match.group(1))
            minutes = gsm8k_seconds // 60
            seconds = gsm8k_seconds % 60
            parsed_data["gsm8k_duration"] = f"{minutes}m {seconds}s"

        # Determine overall status
        # If no tests have been run (empty or all PENDING), consider it a failure
        if not parsed_data["test_results"]:
            # No test results found - test must have failed during setup
            parsed_data["status"] = "fail"
        else:
            # Check if all tests passed
            all_passed = all(
                test.get("status") == "PASS"
                for test in parsed_data["test_results"].values()
            )
            parsed_data["status"] = "pass" if all_passed else "fail"

        # Extract log directory
        log_balance_match = re.search(
            r"Load Balancer:\s*(.+)/load_balance\.log", content
        )
        if log_balance_match:
            parsed_data["log_dir"] = log_balance_match.group(1).strip()

    except FileNotFoundError:
        print(f"‚ùå Error: Summary file not found: {summary_file_path}")
        return None
    except Exception as e:
        print(f"‚ùå Error parsing PD test summary file: {e}")
        import traceback

        traceback.print_exc()
        return None

    return parsed_data


class TestNightlyTeamsNotifier:
    """Handle sending unit test status notifications to Microsoft Teams"""

    def __init__(self, webhook_url: str):
        """
        Initialize Teams notifier for unit tests

        Args:
            webhook_url: Microsoft Teams webhook URL
        """
        self.webhook_url = webhook_url
        self.github_repo = os.environ.get("GITHUB_REPO", "ROCm/sglang-ci")

    def create_test_status_card(
        self,
        status: str,
        runtime: Optional[str] = None,
        hostname: Optional[str] = None,
        docker_image: Optional[str] = None,
        hardware: Optional[str] = None,
        test_name: Optional[str] = None,
        log_file: Optional[str] = None,
        error_details: Optional[str] = None,
    ) -> dict:
        """
        Create adaptive card for unit test status

        Args:
            status: Test status (pass, fail)
            runtime: Test execution runtime
            hostname: Hostname where test ran
            docker_image: Docker image used for testing
            hardware: Hardware type (mi30x, mi35x)
            test_name: Name of the test that ran
            log_file: Path to the log file
            error_details: Additional error information for failed tests

        Returns:
            Adaptive card JSON structure
        """
        # Use San Francisco time (Pacific Time) if pytz is available
        if PYTZ_AVAILABLE:
            pacific_tz = pytz.timezone("America/Los_Angeles")
            pacific_time = datetime.now(pacific_tz)
            current_date = pacific_time.strftime("%Y-%m-%d")
            # Determine if it's PST or PDT
            tz_name = "PDT" if pacific_time.dst() else "PST"
            current_time = pacific_time.strftime(f"%H:%M:%S {tz_name}")
        else:
            current_date = datetime.now().strftime("%Y-%m-%d")
            current_time = datetime.now().strftime("%H:%M:%S UTC")

        # Determine status icon and color
        status_config = {
            "pass": {
                "icon": "‚úÖ",
                "color": "Good",
                "title": "Unit Test Passed",
            },
            "fail": {
                "icon": "‚ùå",
                "color": "Attention",
                "title": "Unit Test Failed",
            },
        }

        config = status_config.get(status, status_config["fail"])

        # Create card body elements
        body_elements = [
            {
                "type": "TextBlock",
                "size": "Large",
                "weight": "Bolder",
                "text": f"{current_date} SGL Nightly Unit Test Results",
            },
            {
                "type": "TextBlock",
                "size": "Small",
                "text": f"Completed on {current_date} at {current_time}",
                "isSubtle": True,
                "spacing": "None",
            },
            {
                "type": "TextBlock",
                "text": "**Test Status:**",
                "weight": "Bolder",
                "size": "Medium",
                "spacing": "Medium",
            },
            {
                "type": "TextBlock",
                "size": "Medium",
                "weight": "Bolder",
                "text": f"{config['icon']} {config['title']}",
                "color": config["color"],
                "wrap": True,
                "spacing": "Small",
            },
        ]

        # Add test details section
        body_elements.append(
            {
                "type": "TextBlock",
                "text": "**unit-test-backend-8-gpu-CAR-amd:**",
                "weight": "Bolder",
                "size": "Medium",
                "spacing": "Medium",
            }
        )

        # Add test detail (actual test name) if provided
        if test_name:
            body_elements.append(
                {
                    "type": "TextBlock",
                    "text": f"‚Ä¢ Test detail: **{test_name}**",
                    "wrap": True,
                    "size": "Small",
                    "spacing": "None",
                }
            )

        # Add Docker image if provided
        if docker_image:
            body_elements.append(
                {
                    "type": "TextBlock",
                    "text": f"‚Ä¢ Docker Image: **{docker_image}**",
                    "wrap": True,
                    "size": "Small",
                    "spacing": "None",
                }
            )

        # Add hostname if provided
        if hostname:
            body_elements.append(
                {
                    "type": "TextBlock",
                    "text": f"‚Ä¢ Hostname: **{hostname}**",
                    "wrap": True,
                    "size": "Small",
                    "spacing": "None",
                }
            )

        # Add hardware type if provided
        if hardware:
            body_elements.append(
                {
                    "type": "TextBlock",
                    "text": f"‚Ä¢ Hardware: **{hardware}**",
                    "wrap": True,
                    "size": "Small",
                    "spacing": "None",
                }
            )

        # Add runtime if provided
        if runtime:
            body_elements.append(
                {
                    "type": "TextBlock",
                    "text": f"‚Ä¢ Runtime: **{runtime}**",
                    "wrap": True,
                    "size": "Small",
                    "spacing": "None",
                }
            )

        # Add error details for failed tests
        if status == "fail" and error_details:
            body_elements.extend(
                [
                    {
                        "type": "TextBlock",
                        "text": "**Error:**",
                        "weight": "Bolder",
                        "size": "Medium",
                        "spacing": "Medium",
                    },
                    {
                        "type": "TextBlock",
                        "text": error_details,
                        "wrap": True,
                        "size": "Small",
                        "spacing": "Small",
                        "color": "Attention",
                    },
                ]
            )

        # Create actions
        actions = []

        # Add cron log link
        # Priority 1: Extract hardware type from hardware parameter
        hw_type = None
        if hardware:
            import re

            hw_match = re.search(r"mi[0-9]+x", hardware)
            if hw_match:
                hw_type = hw_match.group(0)

        # If not found, try docker image
        if not hw_type and docker_image:
            import re

            hw_match = re.search(r"mi[0-9]+x", docker_image)
            if hw_match:
                hw_type = hw_match.group(0)

        # Priority 2: Extract from hostname
        if not hw_type:
            try:
                import re
                import socket

                hostname_str = hostname if hostname else socket.gethostname()
                # Try full pattern first (mi30x, mi35x)
                hw_match = re.search(r"mi[0-9]+x", hostname_str)
                if hw_match:
                    hw_type = hw_match.group(0)
                else:
                    # Try abbreviated patterns and convert to mi30x, mi35x
                    # Pattern 1: 300x, 350x, 355x (with 'x')
                    abbrev_match = re.search(r"([0-9]+)x", hostname_str)
                    if abbrev_match:
                        abbrev = abbrev_match.group(1)
                        # Map 300x -> mi30x, 350x/355x -> mi35x
                        if abbrev in ["300", "30"]:
                            hw_type = "mi30x"
                        elif abbrev in ["350", "355", "35"]:
                            hw_type = "mi35x"
                    # Pattern 2: 300, 355 (without 'x')
                    elif not hw_type:
                        abbrev_match = re.search(
                            r"\b(300|355|350|30|35)\b", hostname_str
                        )
                        if abbrev_match:
                            abbrev = abbrev_match.group(1)
                            # Map 300 -> mi30x, 355/350 -> mi35x
                            if abbrev in ["300", "30"]:
                                hw_type = "mi30x"
                            elif abbrev in ["350", "355", "35"]:
                                hw_type = "mi35x"
            except Exception:
                pass

        # Add CAR log link for failed tests (after hw_type is determined)
        if status == "fail" and hw_type and log_file:
            # Extract log filename from path
            import os
            log_filename = os.path.basename(log_file)
            car_log_file_url = f"https://github.com/{self.github_repo}/blob/log/test/unit-test-backend-8-gpu-CAR-amd/{hw_type}/{log_filename}"
            
            body_elements.append(
                {
                    "type": "TextBlock",
                    "text": f"[Check full error details in CAR log]({car_log_file_url})",
                    "wrap": True,
                    "size": "Small",
                    "spacing": "Small",
                    "isSubtle": True,
                }
            )

        # Add cron log link if we have hardware type
        if hw_type:
            log_date = datetime.now().strftime("%Y%m%d")
            cron_log_url = f"https://github.com/{self.github_repo}/tree/log/cron_log/{hw_type}/{log_date}"
            actions.append(
                {
                    "type": "Action.OpenUrl",
                    "title": "üìã Cron Logs",
                    "url": cron_log_url,
                }
            )

        # Add CAR unit test log link if we have hardware type
        if hw_type:
            car_log_url = f"https://github.com/{self.github_repo}/tree/log/test/unit-test-backend-8-gpu-CAR-amd/{hw_type}"
            actions.append(
                {
                    "type": "Action.OpenUrl",
                    "title": "üìä CAR Logs",
                    "url": car_log_url,
                }
            )
        else:
            # Fallback to general repository link if hardware type not detected
            actions.append(
                {
                    "type": "Action.OpenUrl",
                    "title": "üêô View Repository",
                    "url": "https://github.com/sgl-project/sglang",
                }
            )

        # Create the adaptive card
        card = {
            "type": "message",
            "attachments": [
                {
                    "contentType": "application/vnd.microsoft.card.adaptive",
                    "content": {
                        "type": "AdaptiveCard",
                        "$schema": "http://adaptivecards.io/schemas/adaptive-card.json",
                        "version": "1.4",
                        "body": body_elements,
                        "actions": actions,
                    },
                }
            ],
        }

        return card

    def create_pd_test_status_card(
        self,
        status: str,
        docker_image: Optional[str] = None,
        hardware: Optional[str] = None,
        model: Optional[str] = None,
        hostname: Optional[str] = None,
        router_port: Optional[str] = None,
        prefill_port: Optional[str] = None,
        prefill_gpus: Optional[str] = None,
        decode_port: Optional[str] = None,
        decode_gpus: Optional[str] = None,
        test_results: Optional[Dict] = None,
        gsm8k_accuracy: Optional[str] = None,
        total_runtime: Optional[str] = None,
        setup_time: Optional[str] = None,
        gsm8k_duration: Optional[str] = None,
        log_file: Optional[str] = None,
    ) -> dict:
        """
        Create adaptive card for PD disaggregation test status

        Args:
            status: Test status (pass, fail)
            docker_image: Docker image used for testing
            hardware: Hardware type (mi30x, mi35x)
            model: Model name used for testing
            hostname: Hostname/IP where test ran
            router_port: Load balancer/router port
            prefill_port: Prefill server port
            prefill_gpus: Prefill server GPUs
            decode_port: Decode server port
            decode_gpus: Decode server GPUs
            test_results: Dictionary of test results
            gsm8k_accuracy: GSM8K accuracy result
            total_runtime: Total test runtime
            setup_time: Setup time for all services
            gsm8k_duration: GSM8K test duration
            log_file: Path to the summary file

        Returns:
            Adaptive card JSON structure
        """
        # Use San Francisco time (Pacific Time) if pytz is available
        if PYTZ_AVAILABLE:
            pacific_tz = pytz.timezone("America/Los_Angeles")
            pacific_time = datetime.now(pacific_tz)
            current_date = pacific_time.strftime("%Y-%m-%d")
            # Determine if it's PST or PDT
            tz_name = "PDT" if pacific_time.dst() else "PST"
            current_time = pacific_time.strftime(f"%H:%M:%S {tz_name}")
        else:
            current_date = datetime.now().strftime("%Y-%m-%d")
            current_time = datetime.now().strftime("%H:%M:%S UTC")

        # Determine status icon and color
        status_config = {
            "pass": {
                "icon": "‚úÖ",
                "color": "Good",
                "title": "PD Test Passed",
            },
            "fail": {
                "icon": "‚ùå",
                "color": "Attention",
                "title": "PD Test Failed",
            },
        }

        config = status_config.get(status, status_config["fail"])

        # Create card body elements
        body_elements = [
            {
                "type": "TextBlock",
                "size": "Large",
                "weight": "Bolder",
                "text": f"{current_date} SGL Nightly PD Test Results",
            },
            {
                "type": "TextBlock",
                "size": "Small",
                "text": f"Completed on {current_date} at {current_time}",
                "isSubtle": True,
                "spacing": "None",
            },
            {
                "type": "TextBlock",
                "text": "**Test Status:**",
                "weight": "Bolder",
                "size": "Medium",
                "spacing": "Medium",
            },
            {
                "type": "TextBlock",
                "size": "Medium",
                "weight": "Bolder",
                "text": f"{config['icon']} {config['title']}",
                "color": config["color"],
                "wrap": True,
                "spacing": "Small",
            },
        ]

        # Add test type section
        body_elements.append(
            {
                "type": "TextBlock",
                "text": "**PD Disaggregation Test (Prefill/Decode):**",
                "weight": "Bolder",
                "size": "Medium",
                "spacing": "Medium",
            }
        )

        # Add Docker image if provided
        if docker_image:
            body_elements.append(
                {
                    "type": "TextBlock",
                    "text": f"‚Ä¢ Docker Image: **{docker_image}**",
                    "wrap": True,
                    "size": "Small",
                    "spacing": "None",
                }
            )

        # Add hardware type if provided
        if hardware:
            body_elements.append(
                {
                    "type": "TextBlock",
                    "text": f"‚Ä¢ Hardware: **{hardware}**",
                    "wrap": True,
                    "size": "Small",
                    "spacing": "None",
                }
            )

        # Add model if provided
        if model:
            body_elements.append(
                {
                    "type": "TextBlock",
                    "text": f"‚Ä¢ Model: **{model}**",
                    "wrap": True,
                    "size": "Small",
                    "spacing": "None",
                }
            )

        # Add hostname if provided
        if hostname:
            body_elements.append(
                {
                    "type": "TextBlock",
                    "text": f"‚Ä¢ Hostname: **{hostname}**",
                    "wrap": True,
                    "size": "Small",
                    "spacing": "None",
                }
            )

        # Add configuration section
        body_elements.append(
            {
                "type": "TextBlock",
                "text": "**Configuration:**",
                "weight": "Bolder",
                "size": "Medium",
                "spacing": "Medium",
            }
        )

        if router_port:
            body_elements.append(
                {
                    "type": "TextBlock",
                    "text": f"‚Ä¢ Load Balancer: Port **{router_port}**",
                    "wrap": True,
                    "size": "Small",
                    "spacing": "None",
                }
            )

        if prefill_port and prefill_gpus:
            body_elements.append(
                {
                    "type": "TextBlock",
                    "text": f"‚Ä¢ Prefill Server: Port **{prefill_port}**, GPUs **{prefill_gpus}**, TP=4",
                    "wrap": True,
                    "size": "Small",
                    "spacing": "None",
                }
            )

        if decode_port and decode_gpus:
            body_elements.append(
                {
                    "type": "TextBlock",
                    "text": f"‚Ä¢ Decode Server: Port **{decode_port}**, GPUs **{decode_gpus}**, TP=4",
                    "wrap": True,
                    "size": "Small",
                    "spacing": "None",
                }
            )

        # Add test results section
        if test_results:
            body_elements.append(
                {
                    "type": "TextBlock",
                    "text": "**Test Results:**",
                    "weight": "Bolder",
                    "size": "Medium",
                    "spacing": "Medium",
                }
            )

            # Add individual test results
            test_display_names = {
                "health_check": "Health Check",
                "simple_completion": "Simple Completion",
                "code_generation": "Code Generation",
                "gsm8k": "GSM8K Accuracy",
            }

            for test_key, test_info in test_results.items():
                test_name = test_display_names.get(test_key, test_key)
                test_status = test_info.get("status", "UNKNOWN")
                test_duration = test_info.get("duration", "N/A")
                status_icon = "‚úÖ" if test_status == "PASS" else "‚ùå"

                if test_key == "gsm8k":
                    accuracy = test_info.get("accuracy", "N/A")
                    body_elements.append(
                        {
                            "type": "TextBlock",
                            "text": f"‚Ä¢ {test_name}: {status_icon} **{accuracy}** ({test_duration}s)",
                            "wrap": True,
                            "size": "Small",
                            "spacing": "None",
                        }
                    )
                else:
                    body_elements.append(
                        {
                            "type": "TextBlock",
                            "text": f"‚Ä¢ {test_name}: {status_icon} **{test_status}** ({test_duration}s)",
                            "wrap": True,
                            "size": "Small",
                            "spacing": "None",
                        }
                    )

        # Add timing section
        if setup_time or gsm8k_duration:
            body_elements.append(
                {
                    "type": "TextBlock",
                    "text": "**Timing Summary:**",
                    "weight": "Bolder",
                    "size": "Medium",
                    "spacing": "Medium",
                }
            )

            if setup_time:
                body_elements.append(
                    {
                        "type": "TextBlock",
                        "text": f"‚Ä¢ Setup Time: **{setup_time}**",
                        "wrap": True,
                        "size": "Small",
                        "spacing": "None",
                    }
                )

            if gsm8k_duration:
                body_elements.append(
                    {
                        "type": "TextBlock",
                        "text": f"‚Ä¢ GSM8K Duration: **{gsm8k_duration}**",
                        "wrap": True,
                        "size": "Small",
                        "spacing": "None",
                    }
                )

        # Add troubleshooting section for failures
        if status == "fail":
            body_elements.extend(
                [
                    {
                        "type": "TextBlock",
                        "text": "**Troubleshooting:**",
                        "weight": "Bolder",
                        "size": "Medium",
                        "spacing": "Medium",
                    },
                    {
                        "type": "TextBlock",
                        "text": "‚Ä¢ Check the log directory for detailed error information (prefill.log, decode.log, load_balance.log)",
                        "wrap": True,
                        "size": "Small",
                        "spacing": "Small",
                    },
                    {
                        "type": "TextBlock",
                        "text": "‚Ä¢ Verify Docker containers are running and healthy",
                        "wrap": True,
                        "size": "Small",
                        "spacing": "None",
                    },
                    {
                        "type": "TextBlock",
                        "text": "‚Ä¢ Check GPU resources and network connectivity between prefill/decode servers",
                        "wrap": True,
                        "size": "Small",
                        "spacing": "None",
                    },
                ]
            )

        # Create actions
        actions = []

        # Extract hardware type for cron log link
        hw_type = None
        if hardware:
            hw_match = re.search(r"mi[0-9]+x", hardware)
            if hw_match:
                hw_type = hw_match.group(0)

        # If not found, try docker image
        if not hw_type and docker_image:
            hw_match = re.search(r"mi[0-9]+x", docker_image)
            if hw_match:
                hw_type = hw_match.group(0)

        # Add cron log link if we have hardware type
        if hw_type:
            log_date = datetime.now().strftime("%Y%m%d")
            cron_log_url = f"https://github.com/{self.github_repo}/tree/log/cron_log/{hw_type}/{log_date}"
            actions.append(
                {
                    "type": "Action.OpenUrl",
                    "title": "üìã Cron Logs",
                    "url": cron_log_url,
                }
            )

        # Add GitHub repository link
        actions.append(
            {
                "type": "Action.OpenUrl",
                "title": "üêô View Repository",
                "url": "https://github.com/sgl-project/sglang",
            }
        )

        # Create the adaptive card
        card = {
            "type": "message",
            "attachments": [
                {
                    "contentType": "application/vnd.microsoft.card.adaptive",
                    "content": {
                        "type": "AdaptiveCard",
                        "$schema": "http://adaptivecards.io/schemas/adaptive-card.json",
                        "version": "1.4",
                        "body": body_elements,
                        "actions": actions,
                    },
                }
            ],
        }

        return card

    def create_test_card(self) -> dict:
        """
        Create a simple test card for unit test alerts

        Returns:
            Simple test adaptive card JSON structure
        """
        if PYTZ_AVAILABLE:
            pacific_tz = pytz.timezone("America/Los_Angeles")
            pacific_time = datetime.now(pacific_tz)
            current_time = pacific_time.strftime("%H:%M:%S %Z")
        else:
            current_time = datetime.now().strftime("%H:%M:%S UTC")

        card = {
            "type": "message",
            "attachments": [
                {
                    "contentType": "application/vnd.microsoft.card.adaptive",
                    "content": {
                        "type": "AdaptiveCard",
                        "$schema": "http://adaptivecards.io/schemas/adaptive-card.json",
                        "version": "1.4",
                        "body": [
                            {
                                "type": "TextBlock",
                                "size": "Large",
                                "weight": "Bolder",
                                "text": "üß™ Unit Test Alert Test",
                            },
                            {
                                "type": "TextBlock",
                                "text": f"Sent at {current_time}",
                                "isSubtle": True,
                                "spacing": "None",
                            },
                            {
                                "type": "TextBlock",
                                "text": "‚úÖ If you see this message, your Teams webhook is working correctly for unit test alerts!",
                                "wrap": True,
                                "spacing": "Medium",
                            },
                        ],
                    },
                }
            ],
        }
        return card

    def send_notification(
        self,
        log_file_path: str,
    ) -> bool:
        """
        Send test status notification to Teams by parsing log file
        Automatically detects whether it's a unit test log or PD test summary

        Args:
            log_file_path: Path to the log file or summary file generated by test_nightly.sh

        Returns:
            True if successful, False otherwise
        """
        try:
            # Detect log file type based on filename
            is_pd_test = (
                "test_summary.txt" in log_file_path or "pd_log" in log_file_path
            )

            if is_pd_test:
                # Parse PD test summary file
                print(f"üìã Parsing PD test summary file: {log_file_path}")
                parsed_data = parse_pd_test_summary(log_file_path)
                if parsed_data is None:
                    return False

                # Use parsed hostname, fallback to socket hostname
                hostname = parsed_data["hostname"]
                if hostname is None:
                    try:
                        import socket

                        hostname = socket.gethostname()
                    except Exception:
                        hostname = "unknown"

                card = self.create_pd_test_status_card(
                    status=parsed_data["status"],
                    docker_image=parsed_data["docker_image"],
                    hardware=parsed_data["hardware"],
                    model=parsed_data["model"],
                    hostname=hostname,
                    router_port=parsed_data["router_port"],
                    prefill_port=parsed_data["prefill_port"],
                    prefill_gpus=parsed_data["prefill_gpus"],
                    decode_port=parsed_data["decode_port"],
                    decode_gpus=parsed_data["decode_gpus"],
                    test_results=parsed_data["test_results"],
                    gsm8k_accuracy=parsed_data["gsm8k_accuracy"],
                    total_runtime=parsed_data["total_runtime"],
                    setup_time=parsed_data["setup_time"],
                    gsm8k_duration=parsed_data["gsm8k_duration"],
                    log_file=parsed_data["log_dir"] or log_file_path,
                )
                test_type = "PD"
            else:
                # Parse unit test log file
                print(f"üìã Parsing unit test log file: {log_file_path}")
                parsed_data = parse_test_log(log_file_path)
                if parsed_data is None:
                    return False

                # Use parsed hostname, fallback if not found in log
                hostname = parsed_data["hostname"]
                if hostname is None:
                    try:
                        import socket

                        hostname = socket.gethostname()
                    except Exception:
                        hostname = "unknown"

                card = self.create_test_status_card(
                    parsed_data["status"],
                    parsed_data["runtime"],
                    hostname,
                    parsed_data["docker_image"],
                    parsed_data["hardware"],
                    parsed_data["test_name"],
                    log_file_path,
                    parsed_data["error_details"],
                )
                test_type = "unit"

            card_json = json.dumps(card)
            headers = {"Content-Type": "application/json"}

            response = requests.post(
                self.webhook_url, data=card_json, headers=headers, timeout=30
            )

            if response.status_code in [200, 202]:
                print(
                    f"‚úÖ Successfully sent {test_type} test {parsed_data['status']} alert to Teams"
                )
                if response.status_code == 202:
                    print(
                        "   (Power Automate flow accepted - message processing asynchronously)"
                    )
                return True
            else:
                print(
                    f"‚ùå Failed to send Teams notification. Status: {response.status_code}"
                )
                print(f"Response: {response.text}")
                return False

        except requests.exceptions.RequestException as e:
            print(f"‚ùå Error sending Teams notification: {e}")
            return False
        except json.JSONDecodeError as e:
            print(f"‚ùå JSON encoding error: {e}")
            return False

    def send_test_notification(self) -> bool:
        """
        Send a test notification to Teams

        Returns:
            True if successful, False otherwise
        """
        try:
            card = self.create_test_card()
            card_json = json.dumps(card)

            headers = {"Content-Type": "application/json"}

            response = requests.post(
                self.webhook_url, data=card_json, headers=headers, timeout=30
            )

            if response.status_code in [200, 202]:
                print("‚úÖ Test message sent successfully!")
                if response.status_code == 202:
                    print(
                        "   (Power Automate flow accepted - message processing asynchronously)"
                    )
                return True
            else:
                print(f"‚ùå Test failed. Status: {response.status_code}")
                print(f"Response: {response.text}")
                return False

        except requests.exceptions.RequestException as e:
            print(f"‚ùå Error sending test notification: {e}")
            return False
        except json.JSONDecodeError as e:
            print(f"‚ùå JSON encoding error: {e}")
            return False


def main():
    """Main function"""
    parser = argparse.ArgumentParser(
        description="Send nightly unit test status notifications to Microsoft Teams",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "--webhook-url",
        type=str,
        help="Teams webhook URL (overrides TEAMS_WEBHOOK_URL env var)",
    )

    parser.add_argument(
        "--test-mode",
        action="store_true",
        help="Send a simple test message to verify Teams connectivity",
    )

    parser.add_argument(
        "--log-file",
        type=str,
        help="Path to the log file generated by test_nightly.sh (required unless using --test-mode)",
    )

    args = parser.parse_args()

    # Get webhook URL
    webhook_url = args.webhook_url or os.environ.get("TEAMS_WEBHOOK_URL")
    if not webhook_url:
        print("‚ùå Error: Teams webhook URL not provided")
        print("   Set TEAMS_WEBHOOK_URL environment variable or use --webhook-url")
        return 1

    # Create notifier
    notifier = TestNightlyTeamsNotifier(webhook_url)

    # Handle test mode
    if args.test_mode:
        print("üß™ Test mode: Sending simple unit test alert test")
        success = notifier.send_test_notification()
        return 0 if success else 1

    # Validate required arguments for normal operation
    if not args.log_file:
        print("‚ùå Error: --log-file is required (unless using --test-mode)")
        return 1

    # Send notification
    success = notifier.send_notification(
        log_file_path=args.log_file,
    )

    return 0 if success else 1


if __name__ == "__main__":
    sys.exit(main())
